<!DOCTYPE html>
<html>
<head>
  <title>Snake Duel with Obstacles</title>
  <style>
    canvas {
      border: 3px solid #ff6600;
      background: #000;
      box-shadow: 0 0 20px #ff0000;
    }
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      background: #1a1a1a;
      color: #00ff00;
      font-family: 'Courier New', monospace;
    }
  </style>
</head>
<body>
<div id="score">P1: 0 | P2: 0</div>
<canvas id="gameCanvas" width="800" height="600"></canvas>

<script>
  const CANVAS = document.getElementById('gameCanvas');
  const CTX = CANVAS.getContext('2d');
  const GRID_SIZE = 20;
  const CANVAS_WIDTH = CANVAS.width / GRID_SIZE;
  const CANVAS_HEIGHT = CANVAS.height / GRID_SIZE;

  function generateRandomRectangles() {
    GameState.walls = [];
    const numRectangles = 8;
    const minSize = 2;
    const maxSize = 5;

    for (let i = 0; i < numRectangles; i++) {
      const width = Math.floor(Math.random() * (maxSize - minSize + 1)) + minSize;
      const height = Math.floor(Math.random() * (maxSize - minSize + 1)) + minSize;

      const maxX = CANVAS_WIDTH - width - 1;
      const maxY = CANVAS_HEIGHT - height - 1;

      const x = Math.floor(Math.random() * maxX);
      const y = Math.floor(Math.random() * maxY);

      for (let dx = 0; dx < width; dx++) {
        for (let dy = 0; dy < height; dy++) {
          GameState.walls.push({x: x + dx, y: y + dy});
        }
      }
    }

    GameState.walls = GameState.walls.filter(wall =>
            !(wall.x === 1 && wall.y === 1) &&
            !(wall.x === CANVAS_WIDTH - 2 && wall.y === CANVAS_HEIGHT - 2)
    );
  }

  class Snake {
    constructor(color, controls, startPos) {
      this.body = [startPos];
      this.direction = {x: 0, y: -1};
      this.nextDirection = {x: 0, y: -1};
      this.color = color;
      this.controls = controls;
      this.powerUps = {};
      this.score = 0;
      this.moveCounter = 0;
      this.baseSpeed = 4;
      this.growthQueue = 0;
    }

    get moveDelay() {
      return Math.max(1, Math.floor(this.baseSpeed / (1 + Math.floor(this.score / 5))));
    }

    update() {
      this.moveCounter++;
      if (this.moveCounter >= this.moveDelay) {
        this.moveCounter = 0;
        this.direction = {...this.nextDirection};

        const head = {...this.body[0]};
        head.x += this.direction.x;
        head.y += this.direction.y;

        head.x = (head.x + CANVAS_WIDTH) % CANVAS_WIDTH;
        head.y = (head.y + CANVAS_HEIGHT) % CANVAS_HEIGHT;

        this.body.unshift(head);

        if (this.growthQueue > 0) {
          this.growthQueue--;
        } else {
          this.body.pop();
        }
      }
    }

    grow() {
      this.growthQueue += 1;
    }

    draw() {
      CTX.fillStyle = this.color;
      this.body.forEach(segment => {
        CTX.fillRect(segment.x * GRID_SIZE, segment.y * GRID_SIZE,
                GRID_SIZE - 1, GRID_SIZE - 1);
      });
    }
  }

  class PowerUp {
    constructor(type, position) {
      this.type = type;
      this.position = position;
      this.colors = {
        speed: '#ffff00',
        shield: '#00ffff',
        mine: '#ff00ff',
        apple: '#00ff00'
      };
    }

    draw() {
      CTX.fillStyle = this.colors[this.type];
      CTX.beginPath();
      CTX.arc((this.position.x + 0.5) * GRID_SIZE,
              (this.position.y + 0.5) * GRID_SIZE,
              GRID_SIZE / 2 - 2, 0, Math.PI * 2);
      CTX.fill();
    }
  }

  const GameState = {
    snakes: [
      new Snake('#ff0000', {87: 'up', 83: 'down', 65: 'left', 68: 'right'},
              {x: 1, y: 1}),
      new Snake('#0000ff', {38: 'up', 40: 'down', 37: 'left', 39: 'right'},
              {x: CANVAS_WIDTH - 2, y: CANVAS_HEIGHT - 2})
    ],
    walls: [],
    powerUps: [],
    frameCount: 0
  };

  function drawWalls() {
    CTX.fillStyle = '#ffffff';
    GameState.walls.forEach(wall => {
      CTX.fillRect(wall.x * GRID_SIZE, wall.y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
    });
  }

  function handleInput(e) {
    GameState.snakes.forEach(snake => {
      if (snake.controls[e.keyCode]) {
        const dir = snake.controls[e.keyCode];
        const newDir = {
          up: {x: 0, y: -1},
          down: {x: 0, y: 1},
          left: {x: -1, y: 0},
          right: {x: 1, y: 0}
        }[dir];

        if (Math.abs(newDir.x) !== Math.abs(snake.direction.x) ||
                Math.abs(newDir.y) !== Math.abs(snake.direction.y)) {
          snake.nextDirection = newDir;
        }
      }
    });
  }

  function checkCollisions() {
    GameState.snakes.forEach((snake, index) => {
      const head = snake.body[0];

      // Wall collision
      if (GameState.walls.some(wall => wall.x === head.x && wall.y === head.y)) {
        gameOver(index);
        return;
      }

      // Self collision
      for (let i = 1; i < snake.body.length; i++) {
        if (head.x === snake.body[i].x && head.y === snake.body[i].y) {
          gameOver(index);
          return;
        }
      }

      // Opponent collision
      const opponent = GameState.snakes[(index + 1) % GameState.snakes.length];
      if (opponent.body.some(segment => segment.x === head.x && segment.y === head.y)) {
        gameOver(index);
        return;
      }

      // Power-up collection
      GameState.powerUps = GameState.powerUps.filter(powerUp => {
        if (powerUp.position.x === head.x && powerUp.position.y === head.y) {
          if (powerUp.type === 'apple') {
            snake.grow();
            snake.score += 5;
          }
          return false;
        }
        return true;
      });
    });
  }

  function spawnPowerUp() {
    if (Math.random() < 0.03 && GameState.powerUps.length < 5) {
      let newPosition;
      do {
        newPosition = {
          x: Math.floor(Math.random() * CANVAS_WIDTH),
          y: Math.floor(Math.random() * CANVAS_HEIGHT)
        };
      } while (GameState.walls.some(wall => wall.x === newPosition.x && wall.y === newPosition.y));

      GameState.powerUps.push(new PowerUp('apple', newPosition));
    }
  }

  function gameOver(losingPlayerIndex) {
    const winnerIndex = (losingPlayerIndex + 1) % GameState.snakes.length;
    alert(`Player ${winnerIndex + 1} Wins!`);
    resetGame();
  }

  function resetGame() {
    generateRandomRectangles();
    GameState.snakes.forEach((snake, i) => {
      snake.body = [i === 0 ?
              {x: 1, y: 1} :
              {x: CANVAS_WIDTH - 2, y: CANVAS_HEIGHT - 2}];
      snake.direction = i === 0 ? {x: 1, y: 0} : {x: -1, y: 0};
      snake.nextDirection = {...snake.direction};
      snake.score = 0;
      snake.growthQueue = 0;
    });
    GameState.powerUps = [];
  }

  function updateScore() {
    const scoreElement = document.getElementById('score');
    scoreElement.textContent = `P1: ${GameState.snakes[0].score} | P2: ${GameState.snakes[1].score}`;
  }

  function gameLoop() {
    CTX.fillStyle = '#000000';
    CTX.fillRect(0, 0, CANVAS.width, CANVAS.height);

    drawWalls();
    spawnPowerUp();

    GameState.snakes.forEach(snake => {
      snake.update();
      snake.draw();
    });

    GameState.powerUps.forEach(powerUp => {
      powerUp.draw();
    });

    checkCollisions();
    updateScore();
    GameState.frameCount++;
    requestAnimationFrame(gameLoop);
  }

  document.addEventListener('keydown', handleInput);
  resetGame();
  gameLoop();
</script>
</body>
</html>
