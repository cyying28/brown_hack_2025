<!DOCTYPE html>
<html>
<head>
  <title>Advanced Snake Duel</title>
  <style>
    canvas {
      border: 3px solid #2ecc71;
      background: #2c3e50;
      box-shadow: 0 0 30px rgba(46, 204, 113, 0.5);
    }
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      background: #34495e;
      color: #ecf0f1;
      font-family: 'Courier New', monospace;
      margin: 0;
      padding: 20px;
    }
    .game-info {
      display: flex;
      gap: 20px;
      margin-bottom: 15px;
    }
  </style>
</head>
<body>
<div class="game-info">
  <div id="score">P1: 0 | P2: 0</div>
  <div id="combo">Combo: 1x</div>
</div>
<canvas id="gameCanvas" width="800" height="600"></canvas>

<script>
  const CANVAS = document.getElementById('gameCanvas');
  const CTX = CANVAS.getContext('2d');
  const GRID_SIZE = 20;
  const CANVAS_WIDTH = CANVAS.width / GRID_SIZE;
  const CANVAS_HEIGHT = CANVAS.height / GRID_SIZE;

  class Snake {
    constructor(color, controls, startPos) {
      this.body = [startPos];
      this.direction = {x: 0, y: -1};
      this.nextDirection = {x: 0, y: -1};
      this.color = color;
      this.controls = controls;
      this.score = 0;
      this.moveCounter = 0;
      this.baseSpeed = 8;
      this.growthQueue = 0;
      this.powerUps = new Set();
      this.lastAppleTime = 0;
      this.comboMultiplier = 1;
    }

    get moveDelay() {
      let speed = this.baseSpeed;
      if(this.powerUps.has('speed')) speed /= 2;
      return Math.max(1, Math.floor(speed / (1 + Math.floor(this.score / 10))));
    }

    update() {
      this.moveCounter++;
      if (this.moveCounter >= this.moveDelay) {
        this.moveCounter = 0;
        this.direction = {...this.nextDirection};

        const head = {...this.body[0]};
        head.x = (head.x + this.direction.x + CANVAS_WIDTH) % CANVAS_WIDTH;
        head.y = (head.y + this.direction.y + CANVAS_HEIGHT) % CANVAS_HEIGHT;

        this.body.unshift(head);

        if (this.growthQueue > 0) {
          this.growthQueue--;
        } else {
          this.body.pop();
        }
      }
    }

    grow(amount = 1) {
      this.growthQueue += amount;
    }

    draw() {
      this.body.forEach((segment, index) => {
        const alpha = 1 - (index * 0.02);
        CTX.fillStyle = `rgba(${parseInt(this.color.slice(1,3),16)},
                                ${parseInt(this.color.slice(3,5),16)},
                                ${parseInt(this.color.slice(5,7),16)},
                                ${alpha})`;
        CTX.fillRect(segment.x * GRID_SIZE, segment.y * GRID_SIZE,
                GRID_SIZE - 1, GRID_SIZE - 1);
      });
    }
  }

  class PowerUp {
    constructor(type, position) {
      this.type = type;
      this.position = position;
      this.colors = {
        apple: '#e74c3c',
        speed: '#f1c40f',
        shield: '#3498db',
        bomb: '#9b59b6'
      };
      this.created = Date.now();
      this.blinkTimer = 0;
    }

    draw() {
      this.blinkTimer = (this.blinkTimer + 1) % 30;
      if(this.blinkTimer < 25 || this.type === 'bomb') {
        CTX.fillStyle = this.colors[this.type];
        CTX.beginPath();
        CTX.arc((this.position.x + 0.5) * GRID_SIZE,
                (this.position.y + 0.5) * GRID_SIZE,
                GRID_SIZE / 2 - 2, 0, Math.PI * 2);
        CTX.fill();
      }
    }
  }

  const GameState = {
    snakes: [
      new Snake('#e74c3c', {87: 'up', 83: 'down', 65: 'left', 68: 'right'},
              {x: 10, y: 15}),
      new Snake('#3498db', {38: 'up', 40: 'down', 37: 'left', 39: 'right'},
              {x: 30, y: 15})
    ],
    powerUps: [],
    particles: [],
    frameCount: 0,
    comboResetTimer: 0
  };

  function createParticles(x, y, color) {
    for(let i = 0; i < 10; i++) {
      GameState.particles.push({
        x: x * GRID_SIZE + GRID_SIZE/2,
        y: y * GRID_SIZE + GRID_SIZE/2,
        vx: (Math.random() - 0.5) * 8,
        vy: (Math.random() - 0.5) * 8,
        life: 1,
        color: color
      });
    }
  }

  function handleInput(e) {
    GameState.snakes.forEach(snake => {
      if (snake.controls[e.keyCode]) {
        const dir = snake.controls[e.keyCode];
        const newDir = {
          up: {x: 0, y: -1},
          down: {x: 0, y: 1},
          left: {x: -1, y: 0},
          right: {x: 1, y: 0}
        }[dir];

        if (Math.abs(newDir.x) !== Math.abs(snake.direction.x) ||
                Math.abs(newDir.y) !== Math.abs(snake.direction.y)) {
          snake.nextDirection = newDir;
        }
      }
    });
  }

  function checkCollisions() {
    GameState.snakes.forEach((snake, index) => {
      const head = snake.body[0];
      const now = Date.now();

      // Power-up collection
      GameState.powerUps = GameState.powerUps.filter(powerUp => {
        if (powerUp.position.x === head.x && powerUp.position.y === head.y) {
          createParticles(head.x, head.y, powerUp.colors[powerUp.type]);
          switch(powerUp.type) {
            case 'apple':
              snake.grow();
              snake.score += 10 * snake.comboMultiplier;
              snake.comboMultiplier++;
              snake.lastAppleTime = now;
              GameState.comboResetTimer = 300;
              break;
            case 'speed':
              snake.powerUps.add('speed');
              setTimeout(() => snake.powerUps.delete('speed'), 5000);
              break;
            case 'bomb':
              GameState.snakes[(index + 1) % 2].body.splice(5);
              break;
          }
          return false;
        }
        return true;
      });

      // Self collision
      for (let i = 1; i < snake.body.length; i++) {
        if (head.x === snake.body[i].x && head.y === snake.body[i].y) {
          if(!snake.powerUps.has('shield')) gameOver(index);
          return;
        }
      }

      // Opponent collision
      const opponent = GameState.snakes[(index + 1) % 2];
      if (opponent.body.some(segment => segment.x === head.x && segment.y === head.y)) {
        gameOver(index);
        return;
      }
    });
  }

  function spawnPowerUp() {
    const types = ['apple', 'apple', 'apple', 'speed', 'shield', 'bomb'];
    if(Math.random() < 0.04 && GameState.powerUps.length < 4) {
      const newPowerUp = new PowerUp(
              types[Math.floor(Math.random() * types.length)],
              {
                x: Math.floor(Math.random() * CANVAS_WIDTH),
                y: Math.floor(Math.random() * CANVAS_HEIGHT)
              }
      );
      GameState.powerUps.push(newPowerUp);
    }
  }

  function gameOver(losingPlayerIndex) {
    const winnerIndex = (losingPlayerIndex + 1) % 2;
    GameState.snakes[winnerIndex].score += 100;
    alert(`Player ${winnerIndex + 1} Wins!`);
    resetGame();
  }

  function resetGame() {
    GameState.snakes.forEach((snake, i) => {
      snake.body = [{x: 10 + i * 20, y: 15}];
      snake.direction = {x: 0, y: -1};
      snake.nextDirection = {x: 0, y: -1};
      snake.powerUps.clear();
      snake.growthQueue = 0;
      snake.comboMultiplier = 1;
    });
    GameState.powerUps = [];
    GameState.particles = [];
  }

  function updateScore() {
    document.getElementById('score').textContent =
            `P1: ${GameState.snakes[0].score} | P2: ${GameState.snakes[1].score}`;

    GameState.comboResetTimer--;
    if(GameState.comboResetTimer <= 0) {
      GameState.snakes.forEach(snake => snake.comboMultiplier = 1);
    }
    document.getElementById('combo').textContent =
            `Combo: ${Math.max(...GameState.snakes.map(s => s.comboMultiplier))}x`;
  }

  function gameLoop() {
    CTX.fillStyle = '#2c3e50';
    CTX.fillRect(0, 0, CANVAS.width, CANVAS.height);

    // Update particles
    GameState.particles = GameState.particles.filter(p => {
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.1;
      p.life -= 0.02;
      CTX.fillStyle = p.color;
      CTX.globalAlpha = p.life;
      CTX.fillRect(p.x, p.y, 4, 4);
      return p.life > 0;
    });
    CTX.globalAlpha = 1;

    spawnPowerUp();

    GameState.snakes.forEach(snake => {
      snake.update();
      snake.draw();
    });

    GameState.powerUps.forEach(powerUp => {
      powerUp.draw();
    });

    checkCollisions();
    updateScore();
    GameState.frameCount++;
    requestAnimationFrame(gameLoop);
  }

  document.addEventListener('keydown', handleInput);
  gameLoop();
</script>
</body>
</html>
